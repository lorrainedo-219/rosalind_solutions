# -*- coding: utf-8 -*-
"""Homework 4 - Simple Bioinformatics Scripting

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ykJe0r1lQtjbAOloq6JZoEA6r0Yrkb_6

# **DNA: Counting DNA Nucleotides**

**Given**: A DNA string s of length at most 1000 nt.

**Return**: Four integers (separated by spaces) counting the respective number of times that the symbols 'A', 'C', 'G', and 'T' occur in s
"""

dnaseq = 'CTACGTAGACATACGGGCCCCCTCGGTGTAATCATCCCGTTTTTAAAAGTCCCTGACGTGCAATATGGGCGCTAAAGTAAGGGTGGTGGAACTCCGGGGCTAGGATCTAGATAGGCGTCGTTGTGGCGAACTAGCCGGCGGGGTAATATCTTATACTGGGAGCTAGTACACATTCGCACCTGGTGACTGATATTGTCTCTGTATACCCGAGGTGTACGACCCCCAAGCGCTTACAATTTGTCCGCGGTTGATCAACTCGCTGTAGGCCACAGAGGCATTTGCTTCTTCCTTAGCGTAGGAATTCTGCGACGGGTGGGGACACGGCCTTCATGCCAAAAGGGGCGCGCTCATCTCTGTATAAACTTCCAATGCGACGTGAAAGTTATGGCCCGCGCATGAGGTTAGTGGCCCCAACGGTACTTTGTTCCCATGGCGAGTATCTTAGTGACGACATTGAGGCAGACGATTCGAGGATCGGCTCGCTGTAGGAGGAGACCCGTGGACCCGTGGCGCCCATTAGGCCCATGAACCTACTTCCGTAACCGGCTGATCCACCTCTGAGTCAACCGACTTGTGGATATTGTGGAATGGATGGCGTCCAAATATTCCGCTGCCGTCAATCAGAATAGATAAGTACCAAAATTGAGCATTTCTATTCTAGGCCGGATATACCCCGAACTAGACGATTAGACATCTGCAAAAATGTCATTAAAGTCGAATCGCGGCCTCCCGTTATTACCGGTGTACGTTACTTGGTAAACCAGCTTTGAACGCCAGAGTGTATGGAACGTCTATCTTATCCGATCTATTACAGAAGCGTCTAAAGGTGACATCCAACTCCCGATCTTAGGCTGCGCACACTATTCATCCGTCGGTTCTAGTGCTGGACCAGGATCGAACTATGTTCGGGGCTCTCAGGGTCCAATACACGTGAACAAGCGTTGTGAGGGAATGTGGCTCGCTGTTCAAAACAGGTGCGT'
def nt_count(dnaseq):
  A_count = dnaseq.count('A')
  C_count = dnaseq.count('C')
  G_count = dnaseq.count('G')
  T_count = dnaseq.count('T')
  return A_count, C_count, G_count, T_count

nt_count(dnaseq)

"""# **RNA: Transcribing DNA into RNA**
**Given**: A DNA string t having length at most 1000 nt.

**Return**: The transcribed RNA string of t.
"""

dnaseq = 'AACTAGCATGATGGCCCAGCGGCCTATTTCAACCTCGTGAGATAAGGTGTTCTAGCTCTCCACAAGAGGGGGCGTCTGTTACTAGGTTGGTCGGGAACCAGCGAGGCCTAGAGGCTAGTATGCGTTCAGTCATCGCTGCGCAAAATGAGCGGATTTCAGTCCAGACGGTTCTCCCGGGACGAGAACCGGAGCCTCGGACCGACGGTGGTTCGCGATTACGTTTGCCGTGCACTACCGTAATTCTGGGTCTGTCGTTAGCCAGTTCGCTGTCACTACCCAGGGTATTAGTGGGGGGCTTAGACCACTCGCACGTACCGGCCAGTGACACGGTCGTAGGGAACTTAACTCCTCTTTGTTGAACGGTGCCTAAATATTTTGGTTTATCGAATCTGACACAGATTTGAGCCAACAAGCCAAGGTCATTGCGAACCTCACCAAGTTGAGATGCACACTAAAAAACAAGGCGAGCACTGAATCAGGCTCTGATCATGCATGTTTATTTACACGCAGTTTTACGCTGTGGTATTGCACATGCGTTTAGCACCATTGGTAGTATGCATGAAACGGACATGAGTGGGCATTTGCGCCACCTTCGCTCCGGCTGCACCGTTTGCATCGTCCAATCCACCCGCAGTCGCGTTCTCCGGATATAGCACTATGAATTGCCCTATAAATATACACCAGACTTTTAGCGAGGGGCTCAGGACAGACCCAAGCCTAGAATTATATCAAAAAGTAGGCGCAACGGTCAGTGTTAAGGTGTGGCCAATTCTTGTTTGTCCTTTGGAGGTTCAAAACTATGGTAACTGCTTCCGGGGTGAGCTCGCGCAACTTGGCGTAGTCGCCGGAAGATAGGCACAGTTTGCGTAGGTCGGTACTAGTGCCGCGTTCGTAAGTTAGGAATGCATAG'

def transcribe(dnaseq):
  rna = dnaseq.replace('T','U')
  return rna

transcribe(dnaseq)

"""# **REVC: Complementing a Strand of DNA**
**Given**: A DNA string s of length at most 1000 bp.

**Return**: The reverse complement sc of s.
"""

dnaseq = 'GCCCGATTATACTTTTAAATGTTTGGTCTTTGAGTTCGGTAAGGGGGGCGAAATGACCATACGGAGTTCTGGTATGAGAAAGTTGTGCCCTACCGTTATCTAACTCGCCGGATGACGAAATAGTTAATTGGTGTAGCTTTTCTGATGAAGTCTGCGTTAAACAGAGCGATCCTTTTCCACCTTTCCAATAGTTCAGGTTGTCATACAAGTGGGTATCATCGGCACGTGATGCACACACCATTCTGCATCCCTTATCCGACGGGAGTTGGGCACCACATGGAATGATCGTGTCTTCCCAGTATCAGTCCCTTTTCACTCTGCTGTGAATGGGTCGCACATCACAGTCCGGATTTCCAACCCAATCTTAATGGGAGGAGCGTCTCCAGGCAAGGGTATACGATCTTTCATTATGCACTATTCACACCTTGTCTAGGAATGTATGTAGCGGCAAGCATTTGCCAAGTATTGGAACCGTGGCGCATACGACAGCCGTTGAGAGAAGATGTCACCACCAACGCAGTCAAAGTACAAGGTGACCGCGTAATCCGATATTTCCTCGCTCGCCTGCCTCCCATCACTACCGGCGTAGCAGAGACTCTTCGCCACGGAAGCTAGCCATTATATGGTCCATGACGATATGGACTGGGAGCTCTTTGTCAGCCCAAGGCTCACACGGAGCGGTCAAGGAGACTGGGTTGCGGGTGAGATTGACGAATGACCAAAGTAACACAGAAACAAATAGATGTTAGTTCGGTTCGACATGAACCTAAAAGCCATGAGTGAGACAATTTTCAACCTCCTTCTCATGACTAACATTCAGCAAGTAGGTTGCGGAACAGTGTCTGACGTGCGATGTTCGCACGACGGCAGTGGGCTATACCATCACGACTGTGAGATCTGGAAGGCCAGACAGACACCGTTGAGTCATAGCGTAGCGCCAGCCTCCT'

def complement(dnaseq):
  bp_dict = {'A':'T', 'T':'A', 'C':'G', 'G':'C'}
  rev = dnaseq[::-1]
  comp = ''
  for nt in rev:
    comp += bp_dict[nt]
  return comp

complement(dnaseq)

"""# **GC: Computing GC Content**
**Given**: At most 10 DNA strings in FASTA format (of length at most 1 kbp each).

**Return**: The ID of the string having the highest GC-content, followed by the GC-content of that string. Rosalind allows for a default error of 0.001 in all decimal answers unless otherwise stated; please see the note on absolute error below.
"""

Rosalind_6404 = 'CCTGCGGAAGATCGGCACTAGAATAGCCAGAACCGTTTCTCTGAGGCTTCCGGCCTTCCCTCCCACTAATAATTCTGAGG'
Rosalind_5959 = 'CCATCGGTAGCGCATCCTTAGTCCAATTAAGTCCCTATCCAGGCGCTCCGCCGAAGGTCTATATCCATTTGTCAGCAGACACGC'
Rosalind_0808 = 'CCACCCTCGTGGTATGGCTAGGCATTCAGGAACCGGAGAACGCTTCAGACCAGCCCGGACTGGGAACCTGCGGGCAGTAGGTGGAAT'

def GC_content(seq):
  GC_content = ((seq.count('G') + seq.count('C')) / len(seq)) * 100
  return GC_content

print(GC_content(Rosalind_640))
print(GC_content(Rosalind_0808))
print(GC_content(Rosalind_0808))

"""#**HAMM: Counting Point Mutations**
**Given:** Two DNA strings s and t of equal length (not exceeding 1 kbp).

**Return:** The Hamming distance dH(s,t).
"""

seq1 = 'GAGCCTACTAACGGGAT'
seq2 = 'CATCGTAATGACGGCCT'

def dH(seq1, seq2):
  mutations = 0
  for i in range(len(seq1)):
    if seq1[i] != seq2[i]:
      mutations += 1
  return mutations

dH(seq1, seq2)

"""#**PROT: Translating RNA into Protein**
**Given:** An RNA string s corresponding to a strand of mRNA (of length at most 10 kbp).

**Return:** The protein string encoded by s.
"""

protein_dict = {
      'GCU':'A', 'GCC':'A', 'GCA':'A', 'GCG':'A',
      'UGU':'C','UGC':'C',
      'GAU':'D','GAC':'D',
      'GAA':'E','GAG':'E',
      'UUU':'F','UUC':'F',
      'GGU':'G', 'GGC':'G', 'GGA':'G', 'GGG':'G',
      'CAU':'H','CAC':'H',
      'AUU':'I','AUC':'I','AUA':'I',
      'AAA':'K','AAG':'K',
      'UUA':'L', 'UUG':'L', 'CUU':'L', 'CUC':'L','CUA':'L','CUG':'L',
      'AUG':'M',
      'AAU':'N','AAC':'N',
      'CCU':'P', 'CCC':'P', 'CCA':'P', 'CCG':'P',
      'CAA':'Q','CAG':'Q',
      'CGU':'R', 'CGC':'R', 'CGA':'R', 'CGG':'R','AGA':'R','AGG':'R',
      'UCU':'S', 'UCC':'S', 'UCA':'S', 'UCG':'S','AGU':'S','AGC':'S',
      'ACU':'T', 'ACC':'T', 'ACA':'T', 'ACG':'T',
      'GUU':'V', 'GUC':'V', 'GUA':'V', 'GUG':'V',
      'UGG':'W',
      'UAU':'Y','UAC':'Y',
      'UAA':'STOP', 'UGA':'STOP',
       }

mRNA = 'AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA'

def protein(seq):
  protein =''
  start = seq.find('AUG')
  for i in range(start, len(seq), 3):
    codon = seq[i:i+3]
    aa = protein_dict[codon]
    if aa == 'STOP':
      break
    protein += aa
  return protein

protein(mRNA)

"""# **SUBS:	Finding a Motif in DNA**
**Given**: Two DNA strings s and t (each of length at most 1 kbp).

**Return**: All locations of t as a substring of s.



*   List item
*   List item


"""

seq_s = 'GATATATGCATATACTT'
seq_t = 'ATAT'

def motif(seq1, seq2):
  positions =[]
  for i in range(len(seq_s) - len(seq_t) + 1):
    if seq_s[i:i+len(seq_t)] == seq_t:
        positions.append(i+1)
  return positions

motif(seq_s,seq_t)

"""# **PRTM:	Calculating Protein Mass**

**Given**: A protein string P of length at most 1000 aa.

**Return**: The total weight of P. Consult the monoisotopic mass table.
"""

prot_mass_dict = {'A': 71.03711,
'C': 103.00919,
'D': 115.02694,
'E': 129.04259,
'F': 147.06841,
'G': 57.02146,
'H': 137.05891,
'I': 113.08406,
'K': 128.09496,
'L': 113.08406,
'M': 131.04049,
'N': 114.04293,
'P': 97.05276,
'Q': 128.05858,
'R': 156.10111,
'S': 87.03203,
'T': 101.04768,
'V': 99.06841,
'W': 186.07931,
'Y': 163.06333
             }

protein = 'SKADYEK'

def prot_mass(seq):
  prot_mass = 0
  for P in seq:
    prot_mass += prot_mass_dict[P]
  return prot_mass

prot_mass(protein)

"""# **REVP:	Locating Restriction Sites**

**Given**: A DNA string of length at most 1 kbp in FASTA format.

**Return**: The position and length of every reverse palindrome in the string having length between 4 and 12. You may return these pairs in any order.
"""

Rosalind_24 = 'TCAATGCATGCGGGTCTATATGCAT'

def rev_palindrome(seq):

    bp_dict = {'A':'T', 'T':'A', 'C':'G', 'G':'C'}
    def rev_comp(dna):
        rev = dna[::-1]
        comp = ''
        for nt in rev:
            comp += bp_dict[nt]
        return comp

    results = []

    for i in range(len(seq)):
        for length in range(4, 13):
          fragment = seq[i:i+length]
          if len(fragment) == length and fragment == rev_comp(fragment):
              results.append((i+1, length))

    return results

rev_palindrome(Rosalind_24)

"""# **TRAN:	Transitions and Transversions**
**Given**: Two DNA strings s1 and s2 of equal length (at most 1 kbp).

**Return**: The transition/transversion ratio R(s1,s2).

"""

Rosalind_0209 = 'GCAACGCACAACGAAAACCCTTAGGGACTGGATTATTTCGTGATCGTTGTAGTTATTGGAAGTACGGGCATCAACCCAGTT'
Rosalind_2200 = 'TTATCTGACAAAGAAAGCCGTCAACGGCTGGATAATTTCGCGATCGTGCTGGTTACTGGCGGTACGAGTGTTCCTTTGGGT'

def tt_ratio(seq1,seq2):
  transition = {('A','G'), ('G','A'), ('C','T'), ('T','C')}
  ts = 0
  tv = 0

  for a, b in zip(seq1, seq2):
      if a != b:
          if (a, b) in transition:
              ts += 1
          else:
              tv += 1
  return ts/tv

tt_ratio(Rosalind_0209, Rosalind_2200)